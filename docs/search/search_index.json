{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 We are system security researchers at the Pennsylvania State University. We are interested in improving systems\u2019 security, reliability, and performance. We have built cutting-edge tools that pinpoint thousands of previously unknown bugs and vulnerabilities in famous software. We always have openings for self-motivated Ph.D. students or interns. If you are interested in joining, please contact Hong Hu or Linhai Song .","title":"Home"},{"location":"#introduction","text":"We are system security researchers at the Pennsylvania State University. We are interested in improving systems\u2019 security, reliability, and performance. We have built cutting-edge tools that pinpoint thousands of previously unknown bugs and vulnerabilities in famous software. We always have openings for self-motivated Ph.D. students or interns. If you are interested in joining, please contact Hong Hu or Linhai Song .","title":"Introduction"},{"location":"fundings/","text":"Fundings \u00b6","title":"Fundings"},{"location":"fundings/#fundings","text":"","title":"Fundings"},{"location":"people/","text":"Leaders \u00b6 Linhai Song Hong Hu Graduate Students \u00b6 Shuofei Zhu Yu Liang Shihao Xia Alumni \u00b6 Ziheng Liu 2019-2021 PhD at UCSD Boqin Qin 2018-2019 Visiting PhD from BUPT China Telecom Cloud Computing Ziyi Zhang 2019 Visiting Undergraduate from USTC Undergraduate Silver Medalist in SRC@SOSP'2019 PhD at UW-Madison Jianjun Shi 2018-2019 Visiting PhD from BIT Zeming Yu 2018-2019 Yongheng Chen 2019 Visiting Undergraduate from NJU PhD at Gatech Tengfei Tu 2017-2018 Visiting PhD from BUPT Faculty at BUPT","title":"People"},{"location":"people/#leaders","text":"Linhai Song Hong Hu","title":"Leaders"},{"location":"people/#graduate-students","text":"Shuofei Zhu Yu Liang Shihao Xia","title":"Graduate Students"},{"location":"people/#alumni","text":"Ziheng Liu 2019-2021 PhD at UCSD Boqin Qin 2018-2019 Visiting PhD from BUPT China Telecom Cloud Computing Ziyi Zhang 2019 Visiting Undergraduate from USTC Undergraduate Silver Medalist in SRC@SOSP'2019 PhD at UW-Madison Jianjun Shi 2018-2019 Visiting PhD from BIT Zeming Yu 2018-2019 Yongheng Chen 2019 Visiting Undergraduate from NJU PhD at Gatech Tengfei Tu 2017-2018 Visiting PhD from BUPT Faculty at BUPT","title":"Alumni"},{"location":"generated/publications/","text":"2022 \u00b6 FreeWill: Automatically Diagnosing Use-after-free Bugs via Reference Miscounting Detection on Binaries (To Appear) Liang He, Hong Hu, Purui Su, Yan Cai and Zhenkai Liang In Proceedings of the 31st USENIX Security Symposium (USENIX 2022) Abstract Memory-safety issues in operating systems and popular applications are still top security threats. As one widely exploited vulnerability, Use After Free (UAF) resulted in hundreds of new incidents every year. Existing bug diagnosis techniques report the locations that allocate or deallocate the vulnerable object, but cannot provide sufficient information for developers to reason about a bug or synthesize a correct patch. In this work, we identified incorrect reference counting as one common root cause of UAF bugs: if the developer forgets to increase the counter for a newly created reference, the program may prematurely free the actively used object, rendering other references dangling pointers. We call this problem reference miscounting. By proposing an omission- aware counting model, we developed an automatic method, FreeWill, to diagnose UAF bugs. FreeWill first reproduces a UAF bug and collects related execution trace. Then, it identifies the UAF object and related references. Finally, FreeWill compares reference operations with our model to detect reference miscounting. We evaluated FreeWill on 76 real-world UAF bugs and it successfully confirmed reference miscounting as root causes for 48 bugs and dangling usage for 18 bugs. FreeWill also identified five null-pointer dereference bugs and failed to analyze five bugs. FreeWill can complete its analysis within 15 minutes on average, showing its practicality for diagnosing UAF bugs. Bibtex @inproceedings{he:freewill, address = {Boston, MA}, author = {Liang He and Hong Hu and Purui Su and Yan Cai and Zhenkai Liang}, booktitle = {Proceedings of the 31st USENIX Security Symposium (USENIX 2022)}, month = {August}, title = {{FreeWill: Automatically Diagnosing Use-after-free Bugs via Reference Miscounting Detection on Binaries (To Appear)}}, year = {2022} } Learning and Programming Challenges of Rust: A Mixed-Methods Study (To Appear) Shuofei Zhu , Ziyi Zhang , Boqin Qin, Aiping Xiong and Linhai Song In Proceedings of the 44th International Conference on Software Engineering (ICSE 2022) Bibtex @inproceedings{zhu:icse, address = {Pittsburgh, PA}, author = {Shuofei Zhu* and Ziyi Zhang* and Boqin Qin and Aiping Xiong and Linhai Song}, booktitle = {Proceedings of the 44th International Conference on Software Engineering (ICSE 2022)}, month = {May}, title = {{Learning and Programming Challenges of Rust: A Mixed-Methods Study (To Appear)}}, year = {2022} } Cooper: Testing the Binding Code of Scripting Languages with Cooperative Mutation (To Appear) Peng Xu, Yanhao Wang, Hong Hu and Purui Su In Proceedings of the 29th Annual Network and Distributed System Security Symposium (NDSS 2022) Abstract Scripting languages like JavaScript are being integrated into commercial software to support easy file modification. For example, Adobe Acrobat accepts JavaScript to dynamically manipulate PDF files. To bridge the gap between the high-level scripts and the low-level languages (like C/C++) used to implement the software, a binding layer is necessary to transfer data and transform representations. However, due to the complexity of two sides, the binding code is prone to inconsistent semantics and security holes, which lead to severe vulnerabilities. Existing efforts for testing binding code merely focus on the script side, and thus miss bugs that require special program native inputs. In this paper, we propose cooperative mutation, which modifies both the script code and the program native input to trigger bugs in binding code. Our insight is that many bugs are due to the interplay between the program initial state and the dynamic operations, which can only be triggered through two-dimensional mutations. We develop three novel techniques to enable practical cooperative mutation on popular scripting languages: we first cluster objects into semantics similar classes to reduce the mutation space of native inputs; then, we statistically infer the relationship between script code and object classes based on a large number of executions; at last, we use the inferred relationship to select proper objects and related script code for targeted mutation. We applied our tool, COOPER, on three popular systems that integrate scripting languages, including Adobe Acrobat, Foxit Reader and Microsoft Word. COOPER successfully found 134 previously unknown bugs. We have reported all of them to the developers. At the time of paper publishing, 59 bugs have been fixed and 33 of them are assigned CVE numbers. We are awarded totally 22K dollars bounty for 17 out of all reported bugs. Bibtex @inproceedings{xu:cooper, address = {San Diego, CA}, author = {Peng Xu and Yanhao Wang and Hong Hu and Purui Su}, booktitle = {Proceedings of the 29th Annual Network and Distributed System Security Symposium (NDSS 2022)}, month = {April}, title = {{Cooper: Testing the Binding Code of Scripting Languages with Cooperative Mutation (To Appear)}}, www-url = {https://github.com/TCA-ISCAS/Cooper}, year = {2022} } Beyond Bot Detection: Combating Fraudulent Online Survey Takers (To Appear) Ziyi Zhang, Shuofei Zhu, Jaron Mink, Aiping Xiong, Linhai Song and Gang Wang In Proceedings of the ACM Web Conference 2022 (WWW 2022) Bibtex @inproceedings{zhang:www, address = {Lyon, France}, author = {Ziyi Zhang and Shuofei Zhu and Jaron Mink and Aiping Xiong and Linhai Song and Gang Wang}, booktitle = {Proceedings of the ACM Web Conference 2022 (WWW 2022)}, month = {April}, title = {{Beyond Bot Detection: Combating Fraudulent Online Survey Takers (To Appear)}}, year = {2022} } Who Goes First? Detecting Go Concurrency Bugs via Message Reordering Ziheng Liu , Shihao Xia , Yu Liang, Linhai Song and Hong Hu In Proceedings of the 27th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS 2022) Abstract Go is a young programming language invented to build safe and efficient concurrent programs. It provides goroutines as lightweight threads and channels for inter-goroutine communication. Programmers are encouraged to explicitly pass messages through channels to connect goroutines, with the purpose of reducing the chance of making programming mistakes and introducing concurrency bugs. Go is one of the most beloved programming languages and has already been used to build many critical infrastructure software systems in the data-center environment. However, a recent study shows that channel-related concurrency bugs are still common in Go programs, severely hurting the reliability of Go applications. This paper presents GFuzz, a dynamic detector that can effectively pinpoint channel-related concurrency bugs by mutating the processing orders of concurrent messages. We build GFuzz in three steps. We first adopt an effective approach to identify concurrent messages and transform a program to process those messages in any given order. We then take a fuzzing approach to generate new processing orders by mutating exercised ones and rely on execution feedback to prioritize orders close to triggering bugs. Finally, we design a runtime sanitizer to capture triggered bugs that are missed by the Go runtime. We evaluate GFuzz on seven popular Go software systems, including Docker, Kubernetes, and gRPC. GFuzz finds 184 previously unknown bugs and reports a negligible number of false positives. Programmers have already confirmed 124 reports as real bugs and fixed 67 of them based on our reporting. A careful inspection of the detected concurrency bugs from gRPC shows the effectiveness of each component of GFuzz and confirms the components\u2019 rationality. Bibtex @inproceedings{liu:gfuzz, address = {Lausanne, Switzerland}, author = {Ziheng Liu* and Shihao Xia* and Yu Liang and Linhai Song and Hong Hu}, booktitle = {Proceedings of the 27th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS 2022)}, month = {February--March}, title = {{Who Goes First? Detecting Go Concurrency Bugs via Message Reordering}}, www-url = {https://github.com/system-pclub/GFuzz}, year = {2022} } 2021 \u00b6 Sharing More and Checking Less: Leaveraging Common Input Keywords to Detect Bugs in Embedded Systems Libo Chen, Yanhao Wang, Quanpu Cai, Yunfan Zhan, Hong Hu, Jiaqi Linghu, Qinsheng Hou, Chao Zhang, Haixin Duan and Zhi Xue In Proceedings of the 30th USENIX Security Symposium (USENIX 2021) Abstract IoT devices have brought invaluable convenience to our daily life. However, their pervasiveness also amplifies the impact of security vulnerabilities. Many popular vulnerabilities of embedded systems reside in their vulnerable web services. Unfortunately, existing vulnerability detection methods cannot effectively nor efficiently analyze such web services: they either introduce heavy execution overheads or have many false positives and false negatives. In this paper, we propose a novel static taint checking solution, SaTC, to effectively detect security vulnerabilities in web services provided by embedded devices. Our key insight is that, string literals on web interfaces are commonly shared between front-end files and back-end binaries to encode user input. We thus extract such common keywords from the front-end, and use them to locate reference points in the back-end, which indicate the input entry. Then, we apply targeted data-flow analysis to accurately detect dangerous uses of the untrusted user input. We implemented a prototype of SaTC and evaluated it on 39 embedded system firmwares from six popular vendors. SaTC discovered 33 unknown bugs, of which 30 are confirmed by CVE/CNVD/PSV. Compared to the state-of-the-art tool KARONTE, SaTC found significantly more bugs on the test set. It shows that, SaTC is effective in discovering bugs in embedded systems. Bibtex @inproceedings{chen:satc, address = {Vancouver, B.C., Canada}, author = {Libo Chen and Yanhao Wang and Quanpu Cai and Yunfan Zhan and Hong Hu and Jiaqi Linghu and Qinsheng Hou and Chao Zhang and Haixin Duan and Zhi Xue}, booktitle = {Proceedings of the 30th USENIX Security Symposium (USENIX 2021)}, month = {August}, title = {{Sharing More and Checking Less: Leaveraging Common Input Keywords to Detect Bugs in Embedded Systems}}, www-url = {https://github.com/NSSL-SJTU/SaTC}, year = {2021} } Abusing Hidden Properties to Attack the Node.js Ecosystem Feng Xiao, Jianwei Huang, Yichang Xiong, Guangliang Yang, Hong Hu, Guofei Gu and Wenke Lee In Proceedings of the 30th USENIX Security Symposium (USENIX 2021) Abstract Nowadays, Node.js has been widely used in the development of server-side and desktop programs (e.g., Skype), with its cross-platform and high-performance execution environment of JavaScript. In past years, it has been reported other dynamic programming languages (e.g., PHP and Ruby) are unsafe on sharing objects. However, this security risk is not well studied and understood in JavaScript and Node.js programs. In this paper, we fill the gap by conducting the first systematic study on the communication process between clientand server-side code in Node.js programs. We extensively identify several new vulnerabilities in popular Node.js programs. To demonstrate their security implications, we design and de- velop a novel feasible attack, named hidden property abusing (HPA). Our further analysis shows HPA attacks are subtly different from existing findings regarding exploitation and attack effects. Through HPA attacks, a remote web attacker may obtain dangerous abilities, such as stealing confidential data, bypassing security checks, and launching DoS (Denial of Service) attacks. To help Node.js developers vet their programs against HPA, we design a novel vulnerability detection and verification tool, named LYNX, that utilizes hybrid program analysis to automatically reveal HPA vulnerabilities and even synthesize exploits. We apply LYNX on a set of widely-used Node.js programs and identify 15 previously unknown vulnerabilities. We have reported all of our findings to the Node.js community. 10 of them have been assigned with CVE, and 8 of them are rated as \u201cCritical\u201d or \u201cHigh\u201d severity. This indicates HPA attacks can cause serious security threats. Bibtex @inproceedings{xiao:lynx, address = {Vancouver, B.C., Canada}, author = {Feng Xiao and Jianwei Huang and Yichang Xiong and Guangliang Yang and Hong Hu and Guofei Gu and Wenke Lee}, booktitle = {Proceedings of the 30th USENIX Security Symposium (USENIX 2021)}, month = {August}, title = {{Abusing Hidden Properties to Attack the Node.js Ecosystem}}, www-url = {https://github.com/xiaofen9/Lynx}, year = {2021} } Preventing Use-After-Free Attacks with Fast Forward Allocation Brian Wickman, Hong Hu, Insu Yun, Daehee Jang, JungWon Lim, Sanidhya Kashyap and Taesoo Kim In Proceedings of the 30th USENIX Security Symposium (USENIX 2021) Abstract Memory-unsafe languages are widely used to implement critical systems like kernels and browsers, leading to thousands of memory safety issues every year. A use-after-free bug is a temporal memory error where the program accidentally visits a freed memory location. Recent studies show that useafter-free is one of the most exploited memory vulnerabilities. Unfortunately, previous efforts to mitigate use-after-free bugs are not widely deployed in real-world programs due to either inadequate accuracy or high performance overhead. In this paper, we propose to resurrect the idea of one-time allocation (OTA) and provide a practical implementation with efficient execution and moderate memory overhead. With onetime allocation, the memory manager always returns a distinct memory address for each request. Since memory locations are not reused, attackers cannot reclaim freed objects, and thus cannot exploit use-after-free bugs. We utilize two techniques to render OTA practical: batch page management and the fusion of bump-pointer and fixed-size bins memory allocation styles. Batch page management helps reduce the number of system calls which negatively impact performance, while blending the two allocation methods mitigates the memory overhead and fragmentation issues. We implemented a prototype, called FFmalloc, to demonstrate our techniques. We evaluated FFmalloc on widely used benchmarks and real-world large programs. FFmalloc successfully blocked all tested useafter-free attacks while introducing moderate overhead. The results show that OTA can be a strong and practical solution to thwart use-after-free threats. Bibtex @inproceedings{wickman:ffmalloc, address = {Vancouver, B.C., Canada}, author = {Brian Wickman and Hong Hu and Insu Yun and Daehee Jang and JungWon Lim and Sanidhya Kashyap and Taesoo Kim}, booktitle = {Proceedings of the 30th USENIX Security Symposium (USENIX 2021)}, month = {August}, title = {{Preventing Use-After-Free Attacks with Fast Forward Allocation}}, www-url = {https://github.com/bwickman97/ffmalloc}, year = {2021} } Identifying Behavior Dispatchers for Malware Analysis Kyuhong Park, Burak Sahin, Yongheng Chen, Jisheng Zhao, Evan Downing, Hong Hu and Wenke Lee In Proceedings of the 16th ACM ASIA Conference on Computer and Communications Security (AsiaCCS 2021) Abstract Malware is a major threat to modern computer systems. Malicious behaviors are hidden by a variety of techniques: code obfuscation, message encoding and encryption, etc. Countermeasures have been developed to thwart these techniques in order to expose malicious behaviors. However, these countermeasures rely heavily on identifying specific API calls, which has significant limitations as these calls can be misleading or hidden from the analyst. In this paper, we show that malicious programs share a key component which we call a behavior dispatcher, a code structure which is intercepted between various condition checks and malicious actions. By identifying these behavior dispatchers, a malware analysis can be guided into behavior dispatchers and activate hidden malicious actions more easily. We propose BDHunter, a system that automatically identifies dispatchers to assist triggering malicious behaviors. BDHunter takes advantage of the observation that a dispatcher compares an input with a set of expected values to determine which malicious behaviors to execute next. We evaluate BDHunter on recent malware samples to identify behavior dispatchers and show that these dispatchers can help trigger more malicious behaviors (otherwise hidden). Our experimental results show that BDHunter identifies 77.4% of dispatchers within the top 20 candidates discovered. Furthermore, BDHunter-guided concolic execution successfully triggers 13.0\u00d7 and 2.6\u00d7 more malicious behaviors, compared to unguided symbolic and concolic execution, respectively. These demonstrate that BDHunter effectively identifies behavior dispatchers, which are useful for exposing malicious behaviors. Bibtex @inproceedings{park:bdhunter, address = {Hong Kong, China}, author = {Kyuhong Park and Burak Sahin and Yongheng Chen and Jisheng Zhao and Evan Downing and Hong Hu and Wenke Lee}, booktitle = {Proceedings of the 16th ACM ASIA Conference on Computer and Communications Security (AsiaCCS 2021)}, month = {June}, title = {{Identifying Behavior Dispatchers for Malware Analysis}}, www-url = {https://github.com/kp2bit/bdhunter}, year = {2021} } One Engine to Fuzz 'em All: Generic Language Processor Testing with Semantic Validation Yongheng Chen, Rui Zhong, Hong Hu, Hangfan Zhang, Yupeng Yang, Dinghao Wu and Wenke Lee In Proceedings of the 42nd IEEE Symposium on Security and Privacy (Oakland 2021) Abstract Language processors, such as compilers and interpreters, are indispensable in building modern software. Errors in language processors can lead to severe consequences, like incorrect functionalities or even malicious attacks. However, it is not trivial to automatically test language processors to find bugs. Existing testing methods (or fuzzers) either fail to generate high-quality (i.e., semantically correct) test cases, or only support limited programming languages. In this paper, we propose POLYGLOT, a generic fuzzing framework that generates high-quality test cases for exploring processors of different programming languages. To achieve the generic applicability, POLYGLOT neutralizes the difference in syntax and semantics of programming languages with a uniform immediate representation (IR). To improve the language validity, POLYGLOT performs constrained mutation and semantic validation to preserve syntactic correctness and fix semantic errors. We have applied POLYGLOT on 21 popular language processors of 9 programming languages, and identified 173 new bugs, 113 of which are fixed with 18 CVEs assigned. Our experiments show that POLYGLOT can support a wide range of programming languages, and outperforms existing fuzzers with up to 30\u00d7 improvement in code coverage. Bibtex @inproceedings{chen:polyglot, address = {San Francisco, CA}, author = {Yongheng Chen and Rui Zhong and Hong Hu and Hangfan Zhang and Yupeng Yang and Dinghao Wu and Wenke Lee}, booktitle = {Proceedings of the 42nd IEEE Symposium on Security and Privacy (Oakland 2021)}, month = {May}, title = {{One Engine to Fuzz 'em All: Generic Language Processor Testing with Semantic Validation}}, www-url = {https://github.com/s3team/Polyglot}, year = {2021} } Automatically Detecting and Fixing Concurrency Bugs in Go Software Systems Ziheng Liu, Shuofei Zhu, Boqin Qin, Hao Chen and Linhai Song In Proceedings of the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS 2021) Abstract Go is a statically typed programming language designed for efficient and reliable concurrent programming. For this purpose, Go provides lightweight goroutines and recommends passing messages using channels as a less error-prone means of thread communication. Go has become increasingly popular in recent years and has been adopted to build many important infrastructure software systems. However, a recent empirical study shows that concurrency bugs, especially those due to misuse of channels, exist widely in Go. These bugs severely hurt the reliability of Go concurrent systems. To fight Go concurrency bugs caused by misuse of channels, this paper proposes a static concurrency bug detection system, GCatch, and an automated concurrency bug fixing system, GFix. After disentangling an input Go program, GCatch models the complex channel operations in Go using a novel constraint system and applies a constraint solver to identify blocking bugs. GFix automatically patches blocking bugs detected by GCatch using Go\u2019s channel-related language features. We apply GCatch and GFix to 21 popular Go applications, including Docker, Kubernetes, and gRPC. In total, GCatch finds 149 previously unknown blocking bugs due to misuse of channels and GFix successfully fixes 124 of them. We have reported all detected bugs and generated patches to developers. So far, developers have fixed 125 blocking misuse-of-channel bugs based on our reporting. Among them, 87 bugs are fixed by applying GFix\u2019s patches directly. Bibtex @inproceedings{liu:gcatch, address = {Virtual, USA}, author = {Ziheng Liu and Shuofei Zhu and Boqin Qin and Hao Chen and Linhai Song}, booktitle = {Proceedings of the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS 2021)}, month = {April}, title = {Automatically Detecting and Fixing Concurrency Bugs in Go Software Systems}, www-url = {https://github.com/system-pclub/GCatch}, year = {2021} } WINNIE: Fuzzing Windows Applications with Harness Synthesis and Fast Cloning Jinho Jung, Stephen Tong, Hong Hu, Jungwon Lim, Yonghwi Jin and Taesoo Kim In Proceedings of the 28th Annual Network and Distributed System Security Symposium (NDSS 2021) Abstract Fuzzing is an emerging technique to automatically validate programs and uncover bugs. It has been widely used to test many programs and has found thousands of security vulnerabilities. However, existing fuzzing efforts are mainly centered around Unix-like systems, as Windows imposes unique challenges for fuzzing: a closed-source ecosystem, the heavy use of graphical interfaces and the lack of fast process cloning machinery. In this paper, we propose two solutions to address the challenges Windows fuzzing faces. Our system, WINNIE, first tries to synthesize a harness for the application, a simple program that directly invokes target functions, based on sample executions. It then tests the harness, instead of the original complicated program, using an efficient implementation of fork on Windows. Using these techniques, WINNIE can bypass irrelevant GUI code to test logic deep within the application. We used WINNIE to fuzz 59 closed-source Windows executables, and it successfully generated valid fuzzing harnesses for all of them. In our evaluation, WINNIE can support 2.2\u00d7 more programs than existing Windows fuzzers could, and identified 3.9\u00d7 more program states and achieved 26.6\u00d7 faster execution. In total, WINNIE found 61 unique bugs in 32 Windows executables. Bibtex @inproceedings{jung:winnie, address = {Virtual}, author = {Jinho Jung and Stephen Tong and Hong Hu and Jungwon Lim and Yonghwi Jin and Taesoo Kim}, booktitle = {Proceedings of the 28th Annual Network and Distributed System Security Symposium (NDSS 2021)}, month = {February}, title = {{WINNIE: Fuzzing Windows Applications with Harness Synthesis and Fast Cloning}}, www-url = {https://github.com/sslab-gatech/winnie}, year = {2021} } 2020 \u00b6 Measuring and Modeling the Label Dynamics of Online Anti-Malware Engines Shuofei Zhu, Jianjun Shi, Limin Yang, Boqin Qin, Ziyi Zhang, Linhai Song and Gang Wang In Proceedings of the 29th USENIX Conference on Security Symposium (USENIX 2020) Abstract VirusTotal provides malware labels from a large set of anti-malware engines, and is heavily used by researchers for malware annotation and system evaluation. Since different engines often disagree with each other, researchers have used various methods to aggregate their labels. In this paper, we take a data-driven approach to categorize, reason, and validate common labeling methods used by researchers. We first survey 115 academic papers that use VirusTotal, and identify common methodologies. Then we collect the daily snapshots of VirusTotal labels for more than 14,000 files (including a subset of manually verified ground-truth) from 65 VirusTotal engines over a year. Our analysis validates the benefits of threshold-based label aggregation in stabilizing files' labels, and also points out the impact of poorly-chosen thresholds. We show that hand-picked \"trusted\" engines do not always perform well, and certain groups of engines are strongly correlated and should not be treated independently. Finally, we empirically show certain engines fail to perform in-depth analysis on submitted files and can easily produce false positives. Based on our findings, we offer suggestions for future usage of VirusTotal for data annotation. Bibtex @inproceedings{zhu:usenix, address = {Virtual, USA}, author = {Shuofei Zhu and Jianjun Shi and Limin Yang and Boqin Qin and Ziyi Zhang and Linhai Song and Gang Wang}, booktitle = {Proceedings of the 29th USENIX Conference on Security Symposium (USENIX 2020)}, month = {August}, title = {Measuring and Modeling the Label Dynamics of Online Anti-Malware Engines}, www-url = {https://sfzhu93.github.io/projects/vt/index.html}, year = {2020} } Understanding Memory and Thread Safety Practices and Issues in Real-World Rust Programs Boqin Qin , Yilun Chen , Zeming Yu, Linhai Song and Yiying Zhang In Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2020) Abstract Rust is a young programming language designed for systems software development. It aims to provide safety guarantees like high-level languages and performance efficiency like low-level languages. The core design of Rust is a set of strict safety rules enforced by compile-time checking. To support more low-level controls, Rust allows programmers to bypass these compiler checks to write unsafe code. It is important to understand what safety issues exist in real Rust programs and how Rust safety mechanisms impact programming practices. We performed the first empirical study of Rust by close, manual inspection of 850 unsafe code usages and 170 bugs in five open-source Rust projects, five widely-used Rust libraries, two online security databases, and the Rust standard library. Our study answers three important questions: how and why do programmers write unsafe code, what memory-safety issues real Rust programs have, and what concurrency bugs Rust programmers make. Our study reveals interesting real-world Rust program behaviors and new issues Rust programmers make. Based on our study results, we propose several directions of building Rust bug detectors and built two static bug detectors, both of which revealed previously unknown bugs. Bibtex @inproceedings{qin:rust-study, address = {London, UK}, author = {Boqin Qin* and Yilun Chen* and Zeming Yu and Linhai Song and Yiying Zhang}, booktitle = {Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2020)}, month = {June}, title = {Understanding Memory and Thread Safety Practices and Issues in Real-World Rust Programs}, www-url = {https://github.com/system-pclub/rust-study}, year = {2020} } 2019 \u00b6 Opening the Blackbox of VirusTotal: Analyzing Online Phishing Scan Engines Peng Peng, Limin Yang, Linhai Song and Gang Wang In Proceedings of the 2019 Internet Measurement Conference (IMC 2019) Abstract Online scan engines such as VirusTotal are heavily used by researchers to label malicious URLs and files. Unfortunately, it is not well understood how the labels are generated and how reliable the scanning results are. In this paper, we focus on VirusTotal and its 68 third-party vendors to examine their labeling process on phishing URLs. We perform a series of measurements by setting up our own phishing websites (mimicking PayPal and IRS) and submitting the URLs for scanning. By analyzing the incoming network traffic and the dynamic label changes at VirusTotal, we reveal new insights into how VirusTotal works and the quality of their labels. Among other things, we show that vendors have trouble flagging all phishing sites, and even the best vendors missed 30% of our phishing sites. In addition, the scanning results are not immediately updated to VirusTotal after the scanning, and there are inconsistent results between VirusTotal scan and some vendors' own scanners. Our results reveal the need for developing more rigorous methodologies to assess and make use of the labels obtained from VirusTotal. Bibtex @inproceedings{peng:imc, address = {Amsterdam, Netherlands}, author = {Peng Peng and Limin Yang and Linhai Song and Gang Wang}, booktitle = {Proceedings of the 2019 Internet Measurement Conference (IMC 2019)}, month = {October}, title = {Opening the Blackbox of VirusTotal: Analyzing Online Phishing Scan Engines}, year = {2019} } Understanding Real-World Concurrency Bugs in Go Tengfei Tu, Xiaoyu Liu, Linhai Song and Yiying Zhang In Proceedings of the 24th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS 2019) Abstract Go is a statically-typed programming language that aims to provide a simple, efficient, and safe way to build multi-threaded software. Since its creation in 2009, Go has matured and gained significant adoption in production and open-source software. Go advocates for the usage of message passing as the means of inter-thread communication and provides several new concurrency mechanisms and libraries to ease multi-threading programming. It is important to understand the implication of these new proposals and the comparison of message passing and shared memory synchronization in terms of program errors, or bugs. Unfortunately, as far as we know, there has been no study on Go's concurrency bugs. In this paper, we perform the first systematic study on concurrency bugs in real Go programs. We studied six popular Go software including Docker, Kubernetes, and gRPC. We analyzed 171 concurrency bugs in total, with more than half of them caused by non-traditional, Go-specific problems. Apart from root causes of these bugs, we also studied their fixes, performed experiments to reproduce them, and evaluated them with two publicly-available Go bug detectors. Overall, our study provides a better understanding on Go's concurrency models and can guide future researchers and practitioners in writing better, more reliable Go software and in developing debugging and diagnosis tools for Go. Bibtex @inproceedings{tu:go-study, address = {Providence, RI}, author = {Tengfei Tu and Xiaoyu Liu and Linhai Song and Yiying Zhang}, booktitle = {Proceedings of the 24th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS 2019)}, month = {April}, title = {Understanding Real-World Concurrency Bugs in Go}, year = {2019} }","title":"Publications"},{"location":"generated/publications/#2022","text":"FreeWill: Automatically Diagnosing Use-after-free Bugs via Reference Miscounting Detection on Binaries (To Appear) Liang He, Hong Hu, Purui Su, Yan Cai and Zhenkai Liang In Proceedings of the 31st USENIX Security Symposium (USENIX 2022) Abstract Memory-safety issues in operating systems and popular applications are still top security threats. As one widely exploited vulnerability, Use After Free (UAF) resulted in hundreds of new incidents every year. Existing bug diagnosis techniques report the locations that allocate or deallocate the vulnerable object, but cannot provide sufficient information for developers to reason about a bug or synthesize a correct patch. In this work, we identified incorrect reference counting as one common root cause of UAF bugs: if the developer forgets to increase the counter for a newly created reference, the program may prematurely free the actively used object, rendering other references dangling pointers. We call this problem reference miscounting. By proposing an omission- aware counting model, we developed an automatic method, FreeWill, to diagnose UAF bugs. FreeWill first reproduces a UAF bug and collects related execution trace. Then, it identifies the UAF object and related references. Finally, FreeWill compares reference operations with our model to detect reference miscounting. We evaluated FreeWill on 76 real-world UAF bugs and it successfully confirmed reference miscounting as root causes for 48 bugs and dangling usage for 18 bugs. FreeWill also identified five null-pointer dereference bugs and failed to analyze five bugs. FreeWill can complete its analysis within 15 minutes on average, showing its practicality for diagnosing UAF bugs. Bibtex @inproceedings{he:freewill, address = {Boston, MA}, author = {Liang He and Hong Hu and Purui Su and Yan Cai and Zhenkai Liang}, booktitle = {Proceedings of the 31st USENIX Security Symposium (USENIX 2022)}, month = {August}, title = {{FreeWill: Automatically Diagnosing Use-after-free Bugs via Reference Miscounting Detection on Binaries (To Appear)}}, year = {2022} } Learning and Programming Challenges of Rust: A Mixed-Methods Study (To Appear) Shuofei Zhu , Ziyi Zhang , Boqin Qin, Aiping Xiong and Linhai Song In Proceedings of the 44th International Conference on Software Engineering (ICSE 2022) Bibtex @inproceedings{zhu:icse, address = {Pittsburgh, PA}, author = {Shuofei Zhu* and Ziyi Zhang* and Boqin Qin and Aiping Xiong and Linhai Song}, booktitle = {Proceedings of the 44th International Conference on Software Engineering (ICSE 2022)}, month = {May}, title = {{Learning and Programming Challenges of Rust: A Mixed-Methods Study (To Appear)}}, year = {2022} } Cooper: Testing the Binding Code of Scripting Languages with Cooperative Mutation (To Appear) Peng Xu, Yanhao Wang, Hong Hu and Purui Su In Proceedings of the 29th Annual Network and Distributed System Security Symposium (NDSS 2022) Abstract Scripting languages like JavaScript are being integrated into commercial software to support easy file modification. For example, Adobe Acrobat accepts JavaScript to dynamically manipulate PDF files. To bridge the gap between the high-level scripts and the low-level languages (like C/C++) used to implement the software, a binding layer is necessary to transfer data and transform representations. However, due to the complexity of two sides, the binding code is prone to inconsistent semantics and security holes, which lead to severe vulnerabilities. Existing efforts for testing binding code merely focus on the script side, and thus miss bugs that require special program native inputs. In this paper, we propose cooperative mutation, which modifies both the script code and the program native input to trigger bugs in binding code. Our insight is that many bugs are due to the interplay between the program initial state and the dynamic operations, which can only be triggered through two-dimensional mutations. We develop three novel techniques to enable practical cooperative mutation on popular scripting languages: we first cluster objects into semantics similar classes to reduce the mutation space of native inputs; then, we statistically infer the relationship between script code and object classes based on a large number of executions; at last, we use the inferred relationship to select proper objects and related script code for targeted mutation. We applied our tool, COOPER, on three popular systems that integrate scripting languages, including Adobe Acrobat, Foxit Reader and Microsoft Word. COOPER successfully found 134 previously unknown bugs. We have reported all of them to the developers. At the time of paper publishing, 59 bugs have been fixed and 33 of them are assigned CVE numbers. We are awarded totally 22K dollars bounty for 17 out of all reported bugs. Bibtex @inproceedings{xu:cooper, address = {San Diego, CA}, author = {Peng Xu and Yanhao Wang and Hong Hu and Purui Su}, booktitle = {Proceedings of the 29th Annual Network and Distributed System Security Symposium (NDSS 2022)}, month = {April}, title = {{Cooper: Testing the Binding Code of Scripting Languages with Cooperative Mutation (To Appear)}}, www-url = {https://github.com/TCA-ISCAS/Cooper}, year = {2022} } Beyond Bot Detection: Combating Fraudulent Online Survey Takers (To Appear) Ziyi Zhang, Shuofei Zhu, Jaron Mink, Aiping Xiong, Linhai Song and Gang Wang In Proceedings of the ACM Web Conference 2022 (WWW 2022) Bibtex @inproceedings{zhang:www, address = {Lyon, France}, author = {Ziyi Zhang and Shuofei Zhu and Jaron Mink and Aiping Xiong and Linhai Song and Gang Wang}, booktitle = {Proceedings of the ACM Web Conference 2022 (WWW 2022)}, month = {April}, title = {{Beyond Bot Detection: Combating Fraudulent Online Survey Takers (To Appear)}}, year = {2022} } Who Goes First? Detecting Go Concurrency Bugs via Message Reordering Ziheng Liu , Shihao Xia , Yu Liang, Linhai Song and Hong Hu In Proceedings of the 27th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS 2022) Abstract Go is a young programming language invented to build safe and efficient concurrent programs. It provides goroutines as lightweight threads and channels for inter-goroutine communication. Programmers are encouraged to explicitly pass messages through channels to connect goroutines, with the purpose of reducing the chance of making programming mistakes and introducing concurrency bugs. Go is one of the most beloved programming languages and has already been used to build many critical infrastructure software systems in the data-center environment. However, a recent study shows that channel-related concurrency bugs are still common in Go programs, severely hurting the reliability of Go applications. This paper presents GFuzz, a dynamic detector that can effectively pinpoint channel-related concurrency bugs by mutating the processing orders of concurrent messages. We build GFuzz in three steps. We first adopt an effective approach to identify concurrent messages and transform a program to process those messages in any given order. We then take a fuzzing approach to generate new processing orders by mutating exercised ones and rely on execution feedback to prioritize orders close to triggering bugs. Finally, we design a runtime sanitizer to capture triggered bugs that are missed by the Go runtime. We evaluate GFuzz on seven popular Go software systems, including Docker, Kubernetes, and gRPC. GFuzz finds 184 previously unknown bugs and reports a negligible number of false positives. Programmers have already confirmed 124 reports as real bugs and fixed 67 of them based on our reporting. A careful inspection of the detected concurrency bugs from gRPC shows the effectiveness of each component of GFuzz and confirms the components\u2019 rationality. Bibtex @inproceedings{liu:gfuzz, address = {Lausanne, Switzerland}, author = {Ziheng Liu* and Shihao Xia* and Yu Liang and Linhai Song and Hong Hu}, booktitle = {Proceedings of the 27th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS 2022)}, month = {February--March}, title = {{Who Goes First? Detecting Go Concurrency Bugs via Message Reordering}}, www-url = {https://github.com/system-pclub/GFuzz}, year = {2022} }","title":"2022"},{"location":"generated/publications/#2021","text":"Sharing More and Checking Less: Leaveraging Common Input Keywords to Detect Bugs in Embedded Systems Libo Chen, Yanhao Wang, Quanpu Cai, Yunfan Zhan, Hong Hu, Jiaqi Linghu, Qinsheng Hou, Chao Zhang, Haixin Duan and Zhi Xue In Proceedings of the 30th USENIX Security Symposium (USENIX 2021) Abstract IoT devices have brought invaluable convenience to our daily life. However, their pervasiveness also amplifies the impact of security vulnerabilities. Many popular vulnerabilities of embedded systems reside in their vulnerable web services. Unfortunately, existing vulnerability detection methods cannot effectively nor efficiently analyze such web services: they either introduce heavy execution overheads or have many false positives and false negatives. In this paper, we propose a novel static taint checking solution, SaTC, to effectively detect security vulnerabilities in web services provided by embedded devices. Our key insight is that, string literals on web interfaces are commonly shared between front-end files and back-end binaries to encode user input. We thus extract such common keywords from the front-end, and use them to locate reference points in the back-end, which indicate the input entry. Then, we apply targeted data-flow analysis to accurately detect dangerous uses of the untrusted user input. We implemented a prototype of SaTC and evaluated it on 39 embedded system firmwares from six popular vendors. SaTC discovered 33 unknown bugs, of which 30 are confirmed by CVE/CNVD/PSV. Compared to the state-of-the-art tool KARONTE, SaTC found significantly more bugs on the test set. It shows that, SaTC is effective in discovering bugs in embedded systems. Bibtex @inproceedings{chen:satc, address = {Vancouver, B.C., Canada}, author = {Libo Chen and Yanhao Wang and Quanpu Cai and Yunfan Zhan and Hong Hu and Jiaqi Linghu and Qinsheng Hou and Chao Zhang and Haixin Duan and Zhi Xue}, booktitle = {Proceedings of the 30th USENIX Security Symposium (USENIX 2021)}, month = {August}, title = {{Sharing More and Checking Less: Leaveraging Common Input Keywords to Detect Bugs in Embedded Systems}}, www-url = {https://github.com/NSSL-SJTU/SaTC}, year = {2021} } Abusing Hidden Properties to Attack the Node.js Ecosystem Feng Xiao, Jianwei Huang, Yichang Xiong, Guangliang Yang, Hong Hu, Guofei Gu and Wenke Lee In Proceedings of the 30th USENIX Security Symposium (USENIX 2021) Abstract Nowadays, Node.js has been widely used in the development of server-side and desktop programs (e.g., Skype), with its cross-platform and high-performance execution environment of JavaScript. In past years, it has been reported other dynamic programming languages (e.g., PHP and Ruby) are unsafe on sharing objects. However, this security risk is not well studied and understood in JavaScript and Node.js programs. In this paper, we fill the gap by conducting the first systematic study on the communication process between clientand server-side code in Node.js programs. We extensively identify several new vulnerabilities in popular Node.js programs. To demonstrate their security implications, we design and de- velop a novel feasible attack, named hidden property abusing (HPA). Our further analysis shows HPA attacks are subtly different from existing findings regarding exploitation and attack effects. Through HPA attacks, a remote web attacker may obtain dangerous abilities, such as stealing confidential data, bypassing security checks, and launching DoS (Denial of Service) attacks. To help Node.js developers vet their programs against HPA, we design a novel vulnerability detection and verification tool, named LYNX, that utilizes hybrid program analysis to automatically reveal HPA vulnerabilities and even synthesize exploits. We apply LYNX on a set of widely-used Node.js programs and identify 15 previously unknown vulnerabilities. We have reported all of our findings to the Node.js community. 10 of them have been assigned with CVE, and 8 of them are rated as \u201cCritical\u201d or \u201cHigh\u201d severity. This indicates HPA attacks can cause serious security threats. Bibtex @inproceedings{xiao:lynx, address = {Vancouver, B.C., Canada}, author = {Feng Xiao and Jianwei Huang and Yichang Xiong and Guangliang Yang and Hong Hu and Guofei Gu and Wenke Lee}, booktitle = {Proceedings of the 30th USENIX Security Symposium (USENIX 2021)}, month = {August}, title = {{Abusing Hidden Properties to Attack the Node.js Ecosystem}}, www-url = {https://github.com/xiaofen9/Lynx}, year = {2021} } Preventing Use-After-Free Attacks with Fast Forward Allocation Brian Wickman, Hong Hu, Insu Yun, Daehee Jang, JungWon Lim, Sanidhya Kashyap and Taesoo Kim In Proceedings of the 30th USENIX Security Symposium (USENIX 2021) Abstract Memory-unsafe languages are widely used to implement critical systems like kernels and browsers, leading to thousands of memory safety issues every year. A use-after-free bug is a temporal memory error where the program accidentally visits a freed memory location. Recent studies show that useafter-free is one of the most exploited memory vulnerabilities. Unfortunately, previous efforts to mitigate use-after-free bugs are not widely deployed in real-world programs due to either inadequate accuracy or high performance overhead. In this paper, we propose to resurrect the idea of one-time allocation (OTA) and provide a practical implementation with efficient execution and moderate memory overhead. With onetime allocation, the memory manager always returns a distinct memory address for each request. Since memory locations are not reused, attackers cannot reclaim freed objects, and thus cannot exploit use-after-free bugs. We utilize two techniques to render OTA practical: batch page management and the fusion of bump-pointer and fixed-size bins memory allocation styles. Batch page management helps reduce the number of system calls which negatively impact performance, while blending the two allocation methods mitigates the memory overhead and fragmentation issues. We implemented a prototype, called FFmalloc, to demonstrate our techniques. We evaluated FFmalloc on widely used benchmarks and real-world large programs. FFmalloc successfully blocked all tested useafter-free attacks while introducing moderate overhead. The results show that OTA can be a strong and practical solution to thwart use-after-free threats. Bibtex @inproceedings{wickman:ffmalloc, address = {Vancouver, B.C., Canada}, author = {Brian Wickman and Hong Hu and Insu Yun and Daehee Jang and JungWon Lim and Sanidhya Kashyap and Taesoo Kim}, booktitle = {Proceedings of the 30th USENIX Security Symposium (USENIX 2021)}, month = {August}, title = {{Preventing Use-After-Free Attacks with Fast Forward Allocation}}, www-url = {https://github.com/bwickman97/ffmalloc}, year = {2021} } Identifying Behavior Dispatchers for Malware Analysis Kyuhong Park, Burak Sahin, Yongheng Chen, Jisheng Zhao, Evan Downing, Hong Hu and Wenke Lee In Proceedings of the 16th ACM ASIA Conference on Computer and Communications Security (AsiaCCS 2021) Abstract Malware is a major threat to modern computer systems. Malicious behaviors are hidden by a variety of techniques: code obfuscation, message encoding and encryption, etc. Countermeasures have been developed to thwart these techniques in order to expose malicious behaviors. However, these countermeasures rely heavily on identifying specific API calls, which has significant limitations as these calls can be misleading or hidden from the analyst. In this paper, we show that malicious programs share a key component which we call a behavior dispatcher, a code structure which is intercepted between various condition checks and malicious actions. By identifying these behavior dispatchers, a malware analysis can be guided into behavior dispatchers and activate hidden malicious actions more easily. We propose BDHunter, a system that automatically identifies dispatchers to assist triggering malicious behaviors. BDHunter takes advantage of the observation that a dispatcher compares an input with a set of expected values to determine which malicious behaviors to execute next. We evaluate BDHunter on recent malware samples to identify behavior dispatchers and show that these dispatchers can help trigger more malicious behaviors (otherwise hidden). Our experimental results show that BDHunter identifies 77.4% of dispatchers within the top 20 candidates discovered. Furthermore, BDHunter-guided concolic execution successfully triggers 13.0\u00d7 and 2.6\u00d7 more malicious behaviors, compared to unguided symbolic and concolic execution, respectively. These demonstrate that BDHunter effectively identifies behavior dispatchers, which are useful for exposing malicious behaviors. Bibtex @inproceedings{park:bdhunter, address = {Hong Kong, China}, author = {Kyuhong Park and Burak Sahin and Yongheng Chen and Jisheng Zhao and Evan Downing and Hong Hu and Wenke Lee}, booktitle = {Proceedings of the 16th ACM ASIA Conference on Computer and Communications Security (AsiaCCS 2021)}, month = {June}, title = {{Identifying Behavior Dispatchers for Malware Analysis}}, www-url = {https://github.com/kp2bit/bdhunter}, year = {2021} } One Engine to Fuzz 'em All: Generic Language Processor Testing with Semantic Validation Yongheng Chen, Rui Zhong, Hong Hu, Hangfan Zhang, Yupeng Yang, Dinghao Wu and Wenke Lee In Proceedings of the 42nd IEEE Symposium on Security and Privacy (Oakland 2021) Abstract Language processors, such as compilers and interpreters, are indispensable in building modern software. Errors in language processors can lead to severe consequences, like incorrect functionalities or even malicious attacks. However, it is not trivial to automatically test language processors to find bugs. Existing testing methods (or fuzzers) either fail to generate high-quality (i.e., semantically correct) test cases, or only support limited programming languages. In this paper, we propose POLYGLOT, a generic fuzzing framework that generates high-quality test cases for exploring processors of different programming languages. To achieve the generic applicability, POLYGLOT neutralizes the difference in syntax and semantics of programming languages with a uniform immediate representation (IR). To improve the language validity, POLYGLOT performs constrained mutation and semantic validation to preserve syntactic correctness and fix semantic errors. We have applied POLYGLOT on 21 popular language processors of 9 programming languages, and identified 173 new bugs, 113 of which are fixed with 18 CVEs assigned. Our experiments show that POLYGLOT can support a wide range of programming languages, and outperforms existing fuzzers with up to 30\u00d7 improvement in code coverage. Bibtex @inproceedings{chen:polyglot, address = {San Francisco, CA}, author = {Yongheng Chen and Rui Zhong and Hong Hu and Hangfan Zhang and Yupeng Yang and Dinghao Wu and Wenke Lee}, booktitle = {Proceedings of the 42nd IEEE Symposium on Security and Privacy (Oakland 2021)}, month = {May}, title = {{One Engine to Fuzz 'em All: Generic Language Processor Testing with Semantic Validation}}, www-url = {https://github.com/s3team/Polyglot}, year = {2021} } Automatically Detecting and Fixing Concurrency Bugs in Go Software Systems Ziheng Liu, Shuofei Zhu, Boqin Qin, Hao Chen and Linhai Song In Proceedings of the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS 2021) Abstract Go is a statically typed programming language designed for efficient and reliable concurrent programming. For this purpose, Go provides lightweight goroutines and recommends passing messages using channels as a less error-prone means of thread communication. Go has become increasingly popular in recent years and has been adopted to build many important infrastructure software systems. However, a recent empirical study shows that concurrency bugs, especially those due to misuse of channels, exist widely in Go. These bugs severely hurt the reliability of Go concurrent systems. To fight Go concurrency bugs caused by misuse of channels, this paper proposes a static concurrency bug detection system, GCatch, and an automated concurrency bug fixing system, GFix. After disentangling an input Go program, GCatch models the complex channel operations in Go using a novel constraint system and applies a constraint solver to identify blocking bugs. GFix automatically patches blocking bugs detected by GCatch using Go\u2019s channel-related language features. We apply GCatch and GFix to 21 popular Go applications, including Docker, Kubernetes, and gRPC. In total, GCatch finds 149 previously unknown blocking bugs due to misuse of channels and GFix successfully fixes 124 of them. We have reported all detected bugs and generated patches to developers. So far, developers have fixed 125 blocking misuse-of-channel bugs based on our reporting. Among them, 87 bugs are fixed by applying GFix\u2019s patches directly. Bibtex @inproceedings{liu:gcatch, address = {Virtual, USA}, author = {Ziheng Liu and Shuofei Zhu and Boqin Qin and Hao Chen and Linhai Song}, booktitle = {Proceedings of the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS 2021)}, month = {April}, title = {Automatically Detecting and Fixing Concurrency Bugs in Go Software Systems}, www-url = {https://github.com/system-pclub/GCatch}, year = {2021} } WINNIE: Fuzzing Windows Applications with Harness Synthesis and Fast Cloning Jinho Jung, Stephen Tong, Hong Hu, Jungwon Lim, Yonghwi Jin and Taesoo Kim In Proceedings of the 28th Annual Network and Distributed System Security Symposium (NDSS 2021) Abstract Fuzzing is an emerging technique to automatically validate programs and uncover bugs. It has been widely used to test many programs and has found thousands of security vulnerabilities. However, existing fuzzing efforts are mainly centered around Unix-like systems, as Windows imposes unique challenges for fuzzing: a closed-source ecosystem, the heavy use of graphical interfaces and the lack of fast process cloning machinery. In this paper, we propose two solutions to address the challenges Windows fuzzing faces. Our system, WINNIE, first tries to synthesize a harness for the application, a simple program that directly invokes target functions, based on sample executions. It then tests the harness, instead of the original complicated program, using an efficient implementation of fork on Windows. Using these techniques, WINNIE can bypass irrelevant GUI code to test logic deep within the application. We used WINNIE to fuzz 59 closed-source Windows executables, and it successfully generated valid fuzzing harnesses for all of them. In our evaluation, WINNIE can support 2.2\u00d7 more programs than existing Windows fuzzers could, and identified 3.9\u00d7 more program states and achieved 26.6\u00d7 faster execution. In total, WINNIE found 61 unique bugs in 32 Windows executables. Bibtex @inproceedings{jung:winnie, address = {Virtual}, author = {Jinho Jung and Stephen Tong and Hong Hu and Jungwon Lim and Yonghwi Jin and Taesoo Kim}, booktitle = {Proceedings of the 28th Annual Network and Distributed System Security Symposium (NDSS 2021)}, month = {February}, title = {{WINNIE: Fuzzing Windows Applications with Harness Synthesis and Fast Cloning}}, www-url = {https://github.com/sslab-gatech/winnie}, year = {2021} }","title":"2021"},{"location":"generated/publications/#2020","text":"Measuring and Modeling the Label Dynamics of Online Anti-Malware Engines Shuofei Zhu, Jianjun Shi, Limin Yang, Boqin Qin, Ziyi Zhang, Linhai Song and Gang Wang In Proceedings of the 29th USENIX Conference on Security Symposium (USENIX 2020) Abstract VirusTotal provides malware labels from a large set of anti-malware engines, and is heavily used by researchers for malware annotation and system evaluation. Since different engines often disagree with each other, researchers have used various methods to aggregate their labels. In this paper, we take a data-driven approach to categorize, reason, and validate common labeling methods used by researchers. We first survey 115 academic papers that use VirusTotal, and identify common methodologies. Then we collect the daily snapshots of VirusTotal labels for more than 14,000 files (including a subset of manually verified ground-truth) from 65 VirusTotal engines over a year. Our analysis validates the benefits of threshold-based label aggregation in stabilizing files' labels, and also points out the impact of poorly-chosen thresholds. We show that hand-picked \"trusted\" engines do not always perform well, and certain groups of engines are strongly correlated and should not be treated independently. Finally, we empirically show certain engines fail to perform in-depth analysis on submitted files and can easily produce false positives. Based on our findings, we offer suggestions for future usage of VirusTotal for data annotation. Bibtex @inproceedings{zhu:usenix, address = {Virtual, USA}, author = {Shuofei Zhu and Jianjun Shi and Limin Yang and Boqin Qin and Ziyi Zhang and Linhai Song and Gang Wang}, booktitle = {Proceedings of the 29th USENIX Conference on Security Symposium (USENIX 2020)}, month = {August}, title = {Measuring and Modeling the Label Dynamics of Online Anti-Malware Engines}, www-url = {https://sfzhu93.github.io/projects/vt/index.html}, year = {2020} } Understanding Memory and Thread Safety Practices and Issues in Real-World Rust Programs Boqin Qin , Yilun Chen , Zeming Yu, Linhai Song and Yiying Zhang In Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2020) Abstract Rust is a young programming language designed for systems software development. It aims to provide safety guarantees like high-level languages and performance efficiency like low-level languages. The core design of Rust is a set of strict safety rules enforced by compile-time checking. To support more low-level controls, Rust allows programmers to bypass these compiler checks to write unsafe code. It is important to understand what safety issues exist in real Rust programs and how Rust safety mechanisms impact programming practices. We performed the first empirical study of Rust by close, manual inspection of 850 unsafe code usages and 170 bugs in five open-source Rust projects, five widely-used Rust libraries, two online security databases, and the Rust standard library. Our study answers three important questions: how and why do programmers write unsafe code, what memory-safety issues real Rust programs have, and what concurrency bugs Rust programmers make. Our study reveals interesting real-world Rust program behaviors and new issues Rust programmers make. Based on our study results, we propose several directions of building Rust bug detectors and built two static bug detectors, both of which revealed previously unknown bugs. Bibtex @inproceedings{qin:rust-study, address = {London, UK}, author = {Boqin Qin* and Yilun Chen* and Zeming Yu and Linhai Song and Yiying Zhang}, booktitle = {Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2020)}, month = {June}, title = {Understanding Memory and Thread Safety Practices and Issues in Real-World Rust Programs}, www-url = {https://github.com/system-pclub/rust-study}, year = {2020} }","title":"2020"},{"location":"generated/publications/#2019","text":"Opening the Blackbox of VirusTotal: Analyzing Online Phishing Scan Engines Peng Peng, Limin Yang, Linhai Song and Gang Wang In Proceedings of the 2019 Internet Measurement Conference (IMC 2019) Abstract Online scan engines such as VirusTotal are heavily used by researchers to label malicious URLs and files. Unfortunately, it is not well understood how the labels are generated and how reliable the scanning results are. In this paper, we focus on VirusTotal and its 68 third-party vendors to examine their labeling process on phishing URLs. We perform a series of measurements by setting up our own phishing websites (mimicking PayPal and IRS) and submitting the URLs for scanning. By analyzing the incoming network traffic and the dynamic label changes at VirusTotal, we reveal new insights into how VirusTotal works and the quality of their labels. Among other things, we show that vendors have trouble flagging all phishing sites, and even the best vendors missed 30% of our phishing sites. In addition, the scanning results are not immediately updated to VirusTotal after the scanning, and there are inconsistent results between VirusTotal scan and some vendors' own scanners. Our results reveal the need for developing more rigorous methodologies to assess and make use of the labels obtained from VirusTotal. Bibtex @inproceedings{peng:imc, address = {Amsterdam, Netherlands}, author = {Peng Peng and Limin Yang and Linhai Song and Gang Wang}, booktitle = {Proceedings of the 2019 Internet Measurement Conference (IMC 2019)}, month = {October}, title = {Opening the Blackbox of VirusTotal: Analyzing Online Phishing Scan Engines}, year = {2019} } Understanding Real-World Concurrency Bugs in Go Tengfei Tu, Xiaoyu Liu, Linhai Song and Yiying Zhang In Proceedings of the 24th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS 2019) Abstract Go is a statically-typed programming language that aims to provide a simple, efficient, and safe way to build multi-threaded software. Since its creation in 2009, Go has matured and gained significant adoption in production and open-source software. Go advocates for the usage of message passing as the means of inter-thread communication and provides several new concurrency mechanisms and libraries to ease multi-threading programming. It is important to understand the implication of these new proposals and the comparison of message passing and shared memory synchronization in terms of program errors, or bugs. Unfortunately, as far as we know, there has been no study on Go's concurrency bugs. In this paper, we perform the first systematic study on concurrency bugs in real Go programs. We studied six popular Go software including Docker, Kubernetes, and gRPC. We analyzed 171 concurrency bugs in total, with more than half of them caused by non-traditional, Go-specific problems. Apart from root causes of these bugs, we also studied their fixes, performed experiments to reproduce them, and evaluated them with two publicly-available Go bug detectors. Overall, our study provides a better understanding on Go's concurrency models and can guide future researchers and practitioners in writing better, more reliable Go software and in developing debugging and diagnosis tools for Go. Bibtex @inproceedings{tu:go-study, address = {Providence, RI}, author = {Tengfei Tu and Xiaoyu Liu and Linhai Song and Yiying Zhang}, booktitle = {Proceedings of the 24th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS 2019)}, month = {April}, title = {Understanding Real-World Concurrency Bugs in Go}, year = {2019} }","title":"2019"}]}